In order to complete the project, we will need to construct a genetic
model for Turing Machines. For this, we will need an encoding of Turing
Machines in some serial format; a method of scoring Turing Machines that
favors universality; and a genetic algorithm that fits the problem. In
order to actually see our results, we will also need some way of
visualizing them.

\subsection{Turing Machine Encoding} 

We need to come up with a manner of serially encoding Turing Machines
such that they can be sensibly modified by a genetic
algorithm---essentially, a Turing Machine genome.

\subsection{Turing Machine Scoring} 

We must engineer a way of scoring arbitrary Turing Machines such that those
closer to ``universality'' score higher than those farther away.

We can make the following conjecture: a Turing Machine that is closer to
being universal will have more complex (in the Kolmogorov sense) output
than one that is farther from being universal. Then complexity
approximates universality, and we should give more weight to Turing
Machines that produce complicated-looking output, regardless of what it
is.

Alternatively, we can make use of the definition of a UTM given by David Barker-Plummer \cite{SEP_turing}, where we feed the encoding of a randomly generated Turing Machine along with an randomly generated input to a candidate Turing Machine in the population. We score then score the candidate Turing Machine on how closely its output approximates the output of the randomly generated one.

\subsection{Results Visualization}

As part of our project, we will produce a visualization system for the results of our process. Specifically, we will use the Ruby on Rails web framework to create a web application that displays Turing Machines generated by our algorithm, including genome, structure, and sample output.
