There are many ways to structure a genetic algorithm. 

\subsection{Encoding of a Turing Machine}

\subsubsection{Fitness Evaluation}
The fuction of the fitness evaluation in a Genetic Algorithm is to provide the means of scoring one population candidate against another. The particular formulation that is chosen for a fitness evaluation will effect the entire outcome of any optimziation. For this research, the purpose is to investigate the likely hood that an evolutionary process can produce very "complex" oranisms from "simple" ones. We have taken Turing Machines as our analougs for organisms. Following our stated analogy, the best possible result we can hope for is a population of UTM's. So the fitness function employed must grade Turing Machines that are most like a UTM higher than ones that are less like a UTM.  

There is not simple test for that can be applied to a Turing Machine to determine if it is infact a UTM. If there were, you would simply apply that test to every member of a population and grade them accordingly. Lacking such a test, it is necessary to establish certain measureable qualities of a UTM that could be tested for on a candidate. The fundamental problem with this approach is that when a specific candidate has been shown to share a lot of the qualities that you have associated with a UTM, there is no logical path that can extend that information to show that the candidate is actually a UTM (that's why there is no test). Instead, the data only indicates that the candidate behaves like a UTM for the applied test. We utalize this idea, postulating that the more a candidate behaves like a UTM for our test the more likely it is to actually be a UTM. 

Since a UTM can mimic any other Turing Machine, given that Turing Machine's encoding, it follows that a good test for a population member would be to feed it the encoding of another Turing Machine along with some sample input and grade the candidate on how closely its output matches that of the test Turing Machine on a bit by bit basis. For each bit that is the same between the outputs, the candidate scores a point. Each member of the population, is compared against the same test Turing Machine, and the best survive. 

There is a problem with this type of fitness test though, if you keep the input and test Turing Machine constant throughout the optimization. In this case the test really only checks how well your candidate can mimic a specific turing machine. Even if that specific turing machine happened to be a UTM, the test still only checks how well the candidate can mimic the output for a specific input. To fix this, we choose to produce a composite score for a candidate by averaging the results from testing on three outputs gerenated from three inputs fed through a single test Turing Machine. Futhermore, by allowing the test Turing Machine to mutate slightly (10\%) from one generation to the next, we ensure that the optimization is not producing a population of Turing Machines which mimic a single Turing Machine. The slow drift helps to ensure that the most "universal" candidates will score the best over the entire optimziation. 

