Genetic algorithm optimization is designed to mimic the evolutionary process described by Darwin's Theory. In a genetic algorithm, potential solutions are encoded as strings, the fittest of which survive to produce more solutions. The key to a successful optimization using the Genetic Algorithm is the selection of the fitness function with which to evaluate the subject of the optimization. However, determining the fitness test is not the only step required to execute the optimziation. A method of encoding a TM into a "genome" is required along with some method of reproduction between parent TM. 

\subsubsection{Encoding of a Turing Machine}
The encoding translates a specific TM into a binary string representation of that TM. Binary string encoding was chosen for it's simplicity and well documented use in genetic algorithms. To define the encoding scheme, first it is necessary to define a set of constants for the TM population:
\begin{itemize}
\item NUM_STATES: Total number of states represented in each state table
\item GENE_LENGTH: The number of bits being used to represent a single entry in the state table
\end{itemize}

With these constants selected, the length of the genome becomes fixed to NUM_STATES*GENE_LENGTH bits. The encoding is broken up into GENE_LENGTH segments, so that each gene represents a single entry into a state table which uniquely defines a TM. Each entry in the state table can be represented as a 5-tuple: (entry state, bit read, destination state, write bit, movement). The first GENE_LENGTH-2 bits in a gene represent the 'destination state' of an entry. The next bit is the 'write bit' and the last bit is the 'movement' bit. Note, that since only one bit is allowed for the 'write bit' this encoding scheme fixes the alphabet size to 2. 

For example, with NUM_STATES = 3, GENE_LENGTH=4, take a samle encoding of "011110110100010111111010"

\subsubsection{Fitness Evaluation}
The fuction of the fitness evaluation in a Genetic Algorithm is to provide the means of scoring one population candidate against another. The particular formulation that is chosen for a fitness evaluation will effect the entire outcome of any optimziation. For this research, the purpose is to investigate the likelyhood that an evolutionary process can produce very "complex" oranisms from "simple" ones. We have taken Turing Machines as our analougs for organisms. Following our stated analogy, the best possible result we can hope for is a population of UTM's. So the fitness function employed must grade Turing Machines that are most like a UTM higher than ones that are less like a UTM.  

There is not simple test for that can be applied to a Turing Machine to determine if it is infact a UTM. If there were, you would simply apply that test to every member of a population and grade them accordingly. Lacking such a test, it is necessary to establish certain measureable qualities of a UTM that could be tested for on a candidate. The fundamental problem with this approach is that when a specific candidate has been shown to share a lot of the qualities that you have associated with a UTM, there is no single logical path that can extend that information to show that the candidate is actually a UTM (that's why there is no test!). 

Instead of testing directly for qualities of candiate TM's that are similar to those of a UTM, a more simple fitness evaluation was used, which follows more directly with the stated hypothosis. TMs are scored based on the complexity of their output. This complexity is measured by applying a compression algorithm to the output string of the turing machine, and then using the resulting size of the compressed data as the fitness of the TM. The DEFLATE compression algorithm, a lossless compression algorithm,  was is part of the ruby standard libarary. 

For example, assume that two TMs each produced one of the following outputs: [insert real example here]
\begin{enumerate}
	\item 01010101001001001001000100100100100100010111111111
	\item 01010101010101010101010101010101010101010101010101
\end{enumerate}
The compression of the first output results in a XX bytes of data. The second string, when compressed, results in XX bytes of data. The second string, would have a lower score than the first by XX. 

\subsubsection{Reproduction}
A two-point crossover algorithm is used to produce offspring from parent genomes during the reproduction phase of the algorithm, but it was designed to ensure that any offspring would represnet a viable turing machine. The algorithm selects two numbers at random between NUM_STATES and (2*NUM_STATES-1). Each number represnets a splice point along the length of the chromosome. The two parent chromosomes, a and b, are then combined by breaking them at the splice points and constructing their child by transposing the two outer ends of a with the cut out portion of b. See Figure \ref{fig:gacross} for an illustration of the process. 